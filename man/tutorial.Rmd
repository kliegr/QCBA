---
title: "qCBA tutorial"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data

Let's look at sample data. There are two explanatory attributes (Temperature and Humidity). The target attribute is preference. 


```{r results='hide', message=FALSE}
library(qCBA)
```


```{r}
attach(humtemp)
head(humtemp)
plot(Humidity,Temperature,pch=as.character(Class))
```

## Building a CBA classifier
Association rule learning requires discretized data.


```{r}
  #custom discretization
  data_raw<-humtemp
  data_discr <- humtemp
  temp_breaks <- seq(from=15,to=45,by=5)
  hum_breaks <- c(0,40,60,80,100)
  temp_unique_vals <- setdiff(unique(Temperature),temp_breaks)
  hum_unique_vals <- setdiff(unique(Humidity),hum_breaks)
  data_discr[,1]<-cut(Temperature,breaks=temp_breaks)
  data_discr[,2]<-cut(Humidity,breaks=hum_breaks)
  #change interval syntax from (15,20] to (15;20], which is required by MARC
  data_discr[,1]<-as.factor(unlist(lapply(data_discr[,1], function(x) {gsub(",", ";", x)})))
  data_discr[,2]<-as.factor(unlist(lapply(data_discr[,2], function(x) {gsub(",", ";", x)})))
  
  data_discr[,3] <- as.factor(Class)
  head(data_discr)

```
The discretization split the data space into rectangular regions. Given that we have two attributes, the discovered rule can only correspond to a rectangular region with *borders aligned to the grid*.

```{r}
plotGrid <- function()
{
  for (i in temp_breaks[-1])
  {
    abline(h=i, lty=2)
  }
  for (i in hum_breaks[-1])
  {
    abline(v=i, lty=2)
  }
  
  for (i in temp_unique_vals[-1])
  {
    abline(h=i, lty=3, col="grey")
  }
  for (i in hum_unique_vals[-1])
  {
    abline(v=i, lty=3, col="grey")
  }  
}

plot(Humidity,Temperature,pch=as.character(Class))
plotGrid()


```


The next step is mining association rules. The rule mining is constrained to rules that have values of the Class attribute in the consequent.

```{r message=FALSE}
txns <- as(data_discr, "transactions")
  rules <- apriori(txns, parameter = list(confidence = 0.75, support= 3/nrow(data_discr), minlen=1, maxlen=5))
  inspect(rules)
```
The two rules can be visualized in the feature space as rectangular regions. 

```{r}
#as.character(Class)
plot(Humidity,Temperature,pch=Class,main="CBA model",cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5)



plotGrid()

plotHumTempRule<- function(rules, ruleIndex, border = "blue",col=rgb(0,0,1,alpha=0.3) )
{
  if (typeof(rules)=="S4")
  {
    # rules is a arules rule model
    r <- inspect(rules)[ruleIndex,]
    rule <- paste(unlist(r$lhs[1]),collapse='')
  }
  else
  {
    # rules is a list of rules output by qCBA
    #rule <- rules[ruleIndex,1]
    rule <- rules$rules[ruleIndex]
  }
  temp_coordinates<-unlist(regmatches(rule,regexec("Temperature=.([0-9]+);([0-9]+).",rule)))
  if (length(temp_coordinates)==0)
  {
    #if the temperature literal is missing in the rule, use the following coordinates
    temp_coordinates=c(0,0,50)
  }
  
  hum_coordinates<-unlist(regmatches(rule,regexec("Humidity=.([0-9]+);([0-9]+).",rule)))
  rect(hum_coordinates[2], temp_coordinates[2], hum_coordinates[3], temp_coordinates[3],border=border,col=col)
}
plotHumTempRule(rules,1,border = "blue",col=rgb(0,0,1,alpha=0.3))
plotHumTempRule(rules,2,border = "green",col=rgb(0,1,0,alpha=0.3))
#rect(80, 0, 97, 50,border = "blue",col=rgb(0,0,1,alpha=0.3))
#rect(40, 25, 60, 30,border = "green",col=rgb(0,1,0,alpha=0.3))
dev.copy(png,filename="/home/tomas/Dropbox/KonferenceAakce/MARC/figures/cba.png")
dev.off()
```


Out of the two discovered rules, we will create a CBA classifier.
```{r}
classAtt="Class"
  appearance <- getAppearance(data_discr, classAtt)
  rmCBA <- cba_manual(data_raw,  rules, txns, appearance$rhs, classAtt, cutp= list(), pruning_options=NULL)
```
Note that we are calling `cba_manual()` instead of cba() because we want for demonstration purposes to construct the classifier from a user-generated rule list.

This rule learning task was constructed so that the CBA data coverage pruning does not remove any rule from the classifier. CBA only added default rule to the end, which ensures that the rule list  covers every possible instance.

```{r}
inspect(rmCBA@rules)
```
The accuracy of this model on training data:
```{r pressure, echo=FALSE}
  prediction_cba<-predict(rmCBA,data_discr,discretize=FALSE)
  acc_cba <- CBARuleModelAccuracy(prediction_cba, data_discr[[classAtt]])
  print(paste("Accuracy (CBA):",acc_cba))
```
## Postprocessing CBA output with Quantitative CBA (QCBA)

To build a model, `qcba` needs a cba model and raw (undiscretized) data. Note that number of additional parameters can be also specified - these were left to their default values.
```{r}
rmqCBA <- qcba(cbaRuleModel=rmCBA,datadf=data_raw,loglevel = "WARNING",extensionStrategy= "ConfImprovementAgainstLastConfirmedExtension",minImprovement=0,minCondImprovement=-0.15,minConf = 0.5, createHistorySlot=TRUE)
```
The rule list 

```{r}
print(rmqCBA@rules)
```
*QCBA model*

```{r}
plot(Humidity,Temperature,pch=Class, main="QCBA model",cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5)
plotGrid()
plotHumTempRule(rmqCBA@rules,1,border = "blue",col=rgb(0,0,1,alpha=0.3))
plotHumTempRule(rmqCBA@rules,2,border = "green",col=rgb(0,1,0,alpha=0.3))
#rect(82, 0, 95, 50,border = "blue",col=rgb(0,0,1,alpha=0.3))
#rect(30, 26, 58, 33,border = "green",col=rgb(0,1,0,alpha=0.3))
dev.copy(png,filename="/home/tomas/Dropbox/KonferenceAakce/MARC/figures/qcba.png")
dev.off()
```

```{r clock2, fig.width=7, fig.height=6, fig.show='animate'}
extendHistory <- rmqCBA@history[rmqCBA@history$RID=="1",]
for (i in 1:nrow(extendHistory)) {
  print(i)
  plot(Humidity,Temperature,pch=Class, main="QCBA model",cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1, sub=paste(extendHistory[i,3], "Conf:",round(extendHistory[i,4],2)," Supp:",round(extendHistory[i,5],2)))
  plotGrid()
  plotHumTempRule(extendHistory,i,border = "blue",col=rgb(0,0,1,alpha=0.3))
  }
  
```


```{r message=FALSE,warnings=FALSE,}
prediction <- predict(rmqCBA,data_raw,"firstRule")
acc <- CBARuleModelAccuracy(prediction, data_raw[[rmqCBA@classAtt]])
# print(paste("Accuracy (QCBA):",acc))
```

```{r}
print(paste("Accuracy (QCBA):",acc))
```
By comparing CBA and QCBA output, we can see that on this particular data that the accuracy improved and the rule boundaries were adjusted to better fit the data. 

### Compare CBA and QCBA*

```{r echo=FALSE}
plot(Humidity,Temperature,pch=as.character(Class), main="CBA model",sub=paste("Accuracy:",round(acc_cba,2)))
rect(80, 0, 97, 50,border = "blue",col=rgb(0,0,1,alpha=0.3))
rect(40, 25, 60, 30,border = "green",col=rgb(0,1,0,alpha=0.3))

plot(Humidity,Temperature,pch=as.character(Class), main="QCBA model", ,sub=paste("Accuracy:",round(acc,2)))
rect(82, 0, 95, 50,border = "blue",col=rgb(0,0,1,alpha=0.3))
rect(30, 26, 58, 33,border = "green",col=rgb(0,1,0,alpha=0.3))

```
